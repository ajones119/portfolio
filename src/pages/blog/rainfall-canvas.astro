---
import BlogPost from '../../components/Blog/BlogPost.astro';
import Code from '../../components/Blog/Code.astro';
import Demo from '../../components/Blog/Demo.astro';
import RainfallCanvasBackdrop from '../../components/Blog/RainfallCanvasBackdrop.astro';

const post = {
	title: 'Rainfall Canvas',
	description: 'Creating an interactive rainfall animation with HTML5 Canvas that responds to page elements with splash effects',
	sections: [
		{
			id: 'section-intro',
			title: 'Introduction',
		},
		{
			id: 'section-approach',
			title: 'Approach the Problem',
		},
		{
			id: 'section-base-classes',
			title: 'Base Class',
		},
		{
			id: 'section-animation-loop',
			title: 'Animation Loop',
		},
		{
			id: 'section-detect-elements',
			title: 'Detect HTML Elements',
		},
		{
			id: 'section-splash',
			title: 'Splash',
		},
		{
			id: 'section-final-code',
			title: 'Final Code',
		},
	],
};
---

<BlogPost title={post.title} description={post.description} sections={post.sections}>
	<section id="section-intro">
		<h2>Introduction</h2>
		<p>
			The goal of this project is to have a continuously animated rainfall that can interact with elements on the screen, 
			and doesn't slow down processes with the animation.
		</p>
		<p>
			To achieve this, I created a canvas that fills the entire parent container, and then I use a simple animation loop 
			to draw the rain and splashes. We need to consider how we should run a loop animation, how to track rain drops, 
			and how to quickly paint all of this to a canvas without causing performance issues.
		</p>
	</section>

	<section id="section-approach">
		<h2>Approach the Problem</h2>
		<p>
			We'll start by setting up our canvas and script. We'll need to ensure we have a canvas, then we'll set it to its 
			container size and add a listener to adjust for changing screen sizes.
		</p>
		<Code language="html">
{`<canvas id="garden-canvas" class="w-full h-full"/>
<script type="module">
const canvas = document.getElementById("garden-canvas");

const ctx = canvas.getContext("2d");

if (!ctx) {
  console.log("no context");
}

function resizeCanvas() {
  const container = canvas.parentElement;
  if (container) {
    const rect = container.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
  }
}

resizeCanvas();
window.addEventListener("resize", resizeCanvas);
window.addEventListener("scroll", updateElementPositions);
</script>`}
		</Code>
	</section>

	<section id="section-base-classes">
		<h2>Base Class</h2>
		<p>
			Let's start by considering our state! We'll need to keep track of each rain drop as it passes down the canvas. 
			We can start with an empty class with a few states that we can use to track the rain drop's position, velocity, and size.
		</p>
		<Code language="javascript">
{`class RainDrop {
  x = 0;
  y = 0;
  angle = Math.PI / 2 + Math.PI / 12;
  velocity = 400;
  radius = 2;

  constructor(x, y, angle = Math.PI / 2 + Math.PI / 12) {
    this.x = x;
    this.y = y;
    this.angle = angle;
  }

  update(deltaTime) {}
  draw(ctx) {}
}`}
		</Code>
		<p>
			Notice that this class also has an update and draw function. We'll also add these to our splashes and run them within 
			our animation loop itself.
		</p>
		<p>
			Now we can add the drops to the canvas by tracking a main "state". Here, I decided to allow my canvas to keep 
			numberOfDrops = 50 and a targetFPS = 45. Now we can work on our update and draw functions that will run on each frame.
		</p>
		<p>
			For the update function, we'll use a simple sin + cos to calculate position. This will work well for moving the circular 
			drop, but adding a small streak behind it gives a little more flair to the entire thing. So we'll also add a new trail 
			state to track the last few positions for our draw function later.
		</p>
		<Code language="javascript">
{`update(deltaTime) {
  const speed = (this.velocity * deltaTime) / 1000; // Adjust speed based on delta time

  // add current position to trail
  this.trail.push({ x: this.x, y: this.y });
  if (this.trail.length > 1) {
    this.trail.shift();
  }

  // save previous position
  this.prevX = this.x;
  this.prevY = this.y;

  // set new position
  this.y += Math.sin(this.angle) * speed;
  this.x += Math.cos(this.angle) * speed;
}`}
		</Code>
		<p>
			Now we can add a draw function. This will draw an arc at the current position, and draw a line behind it.
		</p>
		<Code language="javascript">
{`draw(ctx) {
  ctx.fillStyle = mainFill;
  // shadows are a fun but expensive flair
  ctx.shadowColor = mainFill;
  ctx.shadowBlur = 10;

  if (this.trail.length > 0) {
    ctx.strokeStyle = mainFill;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(this.trail[0]?.x, this.trail[0]?.y);
    ctx.lineTo(this.x, this.y);
    ctx.stroke();
  }

  ctx.beginPath();
  ctx.fillStyle = mainFill;
  ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
  ctx.fill();
}`}
		</Code>
		<p>
			Before we can start animating though, we need a way to reset rain drops that go off screen so they don't fall forever. 
			To do this, let's update our `Update` function to catch when a drop has gone too far off screen and reset it to the top again.
		</p>
		<Code language="javascript">
{`update(deltaTime) {
  //...updateFunc

  if (this.y > canvas.height) {
    this.reset();
  }
}

reset() {
  this.y = -10;
  this.x = Math.random() * canvas.width;
  this.trail = [];
}`}
		</Code>
	</section>

	<section id="section-animation-loop">
		<h2>Animation Loop</h2>
		<p>
			Next we'll add our actual animation loop function. This will leverage `requestAnimationFrame` to recursively call itself. 
			In order to keep the backdrop efficient, we'll use the targetFPS to limit the rate we actually commit to render and draw on the canvas.
		</p>
		<Code language="javascript">
{`// set the canvas state
let numberOfDrops = 50;
const targetFPS = 45;

let lastFrameTime = 0;
const frameDelay = 1000 / targetFPS;

function animate(time = 0) {
  const delta = time - lastFrameTime;

  //this allows us to limit the rate we actually draw to the canvas
  if (delta >= frameDelay) {
    lastFrameTime = time;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    //update and draw canvas elements
  }

  // request the next frame
  requestAnimationFrame(animate);
}

// initial function call
animate()`}
		</Code>
	</section>

	<section id="section-detect-elements">
		<h2>Detect HTML Elements</h2>
		<p>
			To make the rain feel more grounded in the page, I wanted the drops to "splash" when they hit real HTML elements—specifically, 
			the cards and buttons inside the parent container.
		</p>
		<p>
			I used <code>getBoundingClientRect()</code> to calculate where these elements are positioned relative to the canvas. Then I update 
			their positions on <code>resize</code> and <code>scroll</code>, storing them in a shared <code>surfacePositions</code> array that's 
			used for collision detection.
		</p>
		<Code language="javascript">
{`function updateElementPositions() {
  const canvasRect = canvas.getBoundingClientRect();
  const container = canvas.parentElement.parentElement;
  container.querySelectorAll(".surface").forEach((button) => {
    const rect = button.getBoundingClientRect();
    surfacePositions.push({
      top: rect.top - canvasRect.top,
      left: rect.left - canvasRect.left,
      right: rect.right - canvasRect.left,
      bottom: rect.bottom - canvasRect.top,
      width: rect.width,
      height: rect.height,
    });
  });
}`}
		</Code>
		<p>
			Each drop checks whether its position intersects one of these rectangles using <code>nodeCollideWithElement</code>:
		</p>
		<Code language="javascript">
{`function nodeCollideWithElement(x, y){ 
  return surfacePositions.some((pos) => {
    return x < pos.right && x > pos.left && y < pos.bottom && y > pos.top;
  });
}`}
		</Code>
		<p>
			If a collision is detected, the drop resets and a set of splash particles is spawned at the impact point. This gives a lovely 
			tactile reaction that ties the canvas into the UI rather than floating on top of it.
		</p>
	</section>

	<section id="section-splash">
		<h2>Splash</h2>
		<p>
			When a rain drop hits an element, I wanted a little spark of feedback — something subtle but visually satisfying. I achieved this 
			by generating a few <code>SplashDrop</code> particles at the point of impact. Each splash is just a small particle with basic 
			gravity and velocity, giving it a quick arc motion before falling out of view.
		</p>
		<Code language="javascript">
{`class SplashDrop {
  x = 0;
  y = 0;
  vx = 0;
  vy = 0;
  gravity = 0.4;
  radius = 0.5;
  canRemove = false;

  constructor(x, y, angle = Math.PI / 4, speed = 0.25) {
    this.x = x;
    this.y = y;
    this.vx = Math.cos(angle) * speed;
    this.vy = Math.sin(angle) * -speed;
  }

  update(deltaTime) {
    this.vy += (this.gravity * deltaTime) / 1000;
    this.x += this.vx * deltaTime;
    this.y += this.vy * deltaTime;

    if (this.y > canvas.height) {
      this.canRemove = true;
    }
  }

  draw(ctx) {
    ctx.beginPath();
    ctx.fillStyle = mainFill;
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fill();
  }
}`}
		</Code>
		<p>
			Each splash drop fades naturally as it falls off screen. In the animation loop, splashes are updated and drawn just like raindrops 
			— and removed once they're done:
		</p>
		<Code language="javascript">
{`splashes.forEach((splash) => {
  splash.update(delta);
  splash.draw(ctx);
});
splashes = splashes.filter((splash) => !splash.canRemove);`}
		</Code>
		<p>
			To create the splash, I spawn 3 particles at slightly different angles when a raindrop hits an HTML element:
		</p>
		<Code language="javascript">
{`if (nodeCollideWithElement(this.x, this.y)) {
  splashes.push(new SplashDrop(this.x, this.y, Math.PI / 3));
  splashes.push(new SplashDrop(this.x, this.y, Math.PI / 2));
  splashes.push(new SplashDrop(this.x, this.y, Math.PI / 1.25));
  this.reset();
}`}
		</Code>
		<p>
			It's a subtle but effective way to make the rain feel reactive and alive, especially when it interacts with hoverable or clickable 
			areas in the UI.
		</p>
	</section>

	<section id="section-final-code">
		<h2>Final Code</h2>
		<p>
			Here's a live demo of the rainfall canvas in action. The rain will interact with elements marked with the "surface" class.
		</p>
		<Demo sectionId="rainfall-demo" title="Rainfall Canvas Demo">
			<div class="relative min-h-[400px] w-full overflow-hidden rounded-lg border-2 border-tertiary rainfall-canvas-container">
				<!-- Backdrop: fills container -->
				<div class="absolute inset-0 z-0">
					<RainfallCanvasBackdrop />
				</div>

				<!-- Content: centers vertically and horizontally -->
				<div class="relative z-10 flex flex-col items-center justify-center min-h-[400px] gap-6 px-4">
					<div class="p-4 w-fit border border-tertiary rounded-md surface text-primary max-w-md hover:bg-quaternary/20 transition-all">
						<p class="text-lg font-playfair-display italic">Release your inhibitions</p>
					</div>
					<div class="p-4 min-w-fit border border-tertiary rounded-md surface text-primary max-w-md hover:bg-quaternary/20 transition-all">
						<p class="text-2xl font-bold font-abril-fatface">Feel the rain on your skin</p>
					</div>
				</div>
			</div>
		</Demo>
		<p class="mt-4">
			You can see the complete implementation on CodePen:
		</p>
		<p class="codepen" data-height="600" data-default-tab="html,result" data-slug-hash="EaVKNGR" data-pen-title="Rain Canvas" data-user="Aramis-Jones" style="height: 300px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid var(--color-tertiary); margin: 1em 0; padding: 1em; border-radius: 8px;">
			<span>See the Pen <a href="https://codepen.io/Aramis-Jones/pen/EaVKNGR">
			Rain Canvas</a> by Aramis Jones (<a href="https://codepen.io/Aramis-Jones">@Aramis-Jones</a>)
			on <a href="https://codepen.io">CodePen</a>.</span>
		</p>
		<script async src="https://public.codepenassets.com/embed/index.js"></script>
	</section>
</BlogPost>

<style>
	.surface {
		cursor: pointer;
	}

	.rainfall-canvas-container {
		width: 100%;
		max-width: 100%;
	}

	#demo-rainfall-demo .demo-container {
		width: 100%;
		max-width: 100%;
	}
</style>

